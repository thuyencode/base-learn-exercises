{
  "language": "Solidity",
  "sources": {
    "contracts/Arrays/ArraysExercise.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract ArraysExercise {\n    uint[] public numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    uint[] public timestamps;\n    address[] public senders;\n\n    uint8 private afterY2KCount;\n\n    function getNumbers() external view returns (uint[] memory) {\n        return numbers;\n    }\n\n    function appendToNumbers(uint[] calldata _toAppend) external {\n        for (uint i; i < _toAppend.length; i++) {\n            numbers.push(_toAppend[i]);\n        }\n    }\n\n    function saveTimestamp(uint _unixTimestamp) external {\n        timestamps.push(_unixTimestamp);\n        senders.push(msg.sender);\n\n        if (_unixTimestamp > 946702800) {\n            afterY2KCount++;\n        }\n    }\n\n    function afterY2K()\n        external\n        view\n        returns (uint[] memory _timestamps, address[] memory _senders)\n    {\n        uint index = 0;\n\n        _timestamps = new uint[](afterY2KCount);\n        _senders = new address[](afterY2KCount);\n\n        for (uint i; i < timestamps.length; i++) {\n            if (timestamps[i] > 946702800) {\n                _timestamps[index] = timestamps[i];\n                _senders[index] = senders[i];\n\n                index++;\n            }\n        }\n    }\n\n    function resetNumbers() public {\n        delete numbers;\n\n        uint8 length = 10;\n        numbers = new uint[](length);\n\n        for (uint i; i < length; i++) {\n            numbers[i] = i + 1;\n        }\n    }\n\n    function resetSenders() public {\n        delete senders;\n    }\n\n    function resetTimestamps() public {\n        afterY2KCount = 0;\n        delete timestamps;\n    }\n}\n"
    },
    "contracts/ControlStructures/ControlStructures.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract ControlStructures {\n    function fizzBuzz(\n        uint _number\n    ) external pure returns (string memory _result) {\n        _result = \"Splat\";\n\n        if (_number % 3 == 0) {\n            _result = \"Fizz\";\n        }\n\n        if (_number % 5 == 0) {\n            _result = string.concat(_result, \"Buzz\");\n        }\n    }\n\n    error AfterHours(uint _time);\n\n    function doNotDisturb(\n        uint _time\n    ) external pure returns (string memory _message) {\n        assert(_time < 2400);\n\n        if (_time < 800 || _time > 2200) {\n            revert AfterHours(_time);\n        }\n\n        if (_time >= 1200 && _time <= 1259) {\n            revert(\"At lunch\");\n        }\n\n        if (_time >= 800 && _time <= 1199) {\n            _message = \"Morning!\";\n        }\n\n        if (_time >= 1300 && _time <= 1799) {\n            _message = \"Afternoon!\";\n        }\n\n        if (_time >= 1800 && _time <= 2200) {\n            _message = \"Evening\";\n        }\n    }\n}\n"
    },
    "contracts/Deploying/BasicMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract BasicMath {\n    function adder(\n        uint _a,\n        uint _b\n    ) external pure returns (uint _sum, bool _error) {\n        unchecked {\n            _sum = _a + _b;\n\n            if (_sum < _a) {\n                _sum = 0;\n                _error = true;\n            }\n        }\n    }\n\n    function subtractor(\n        uint _a,\n        uint _b\n    ) external pure returns (uint _difference, bool _error) {\n        if (_b > _a) {\n            _error = true;\n        } else {\n            _difference = _a - _b;\n        }\n    }\n}\n"
    },
    "contracts/Errors/ErrorTriageExercise.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract ErrorTriageExercise {\n    function _absSubtractor(\n        uint _a,\n        uint _b\n    ) private pure returns (uint _difference) {\n        int a = int(_a);\n        int b = int(_b);\n\n        int difference = a - b;\n\n        if (difference < 0) {\n            _difference = uint(-difference);\n        } else {\n            _difference = uint(difference);\n        }\n    }\n\n    /**\n     * Finds the difference between each uint with it's neighbor (a to b, b to c, etc.)\n     * and returns a uint array with the absolute integer difference of each pairing.\n     */\n    function diffWithNeighbor(\n        uint _a,\n        uint _b,\n        uint _c,\n        uint _d\n    ) public pure returns (uint[] memory) {\n        uint[] memory results = new uint[](3);\n\n        results[0] = _absSubtractor(_a, _b);\n        results[1] = _absSubtractor(_b, _c);\n        results[2] = _absSubtractor(_c, _d);\n\n        return results;\n    }\n\n    /**\n     * Changes the _base by the value of _modifier. Base is always >= 1000. Modifiers can be\n     * between positive and negative 100;\n     */\n    function applyModifier(int _base, int _modifier) public pure returns (int) {\n        return _base + _modifier;\n    }\n\n    /**\n     * Pop the last element from the supplied array, and return the popped\n     * value (unlike the built-in function)\n     */\n    uint[] arr;\n\n    function popWithReturn() public returns (uint _element) {\n        uint index = arr.length - 1;\n        _element = arr[index];\n\n        arr.pop();\n    }\n\n    // The utility functions below are working as expected\n    function addToArr(uint _num) public {\n        arr.push(_num);\n    }\n\n    function getArr() public view returns (uint[] memory) {\n        return arr;\n    }\n\n    function resetArr() public {\n        delete arr;\n    }\n}\n"
    },
    "contracts/Imports/ImportsExercise.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {SillyStringUtils} from \"./SillyStringUtils.sol\";\n\ncontract ImportsExercise {\n    using SillyStringUtils for string;\n\n    SillyStringUtils.Haiku public haiku;\n\n    function saveHaiku(\n        string calldata _line1,\n        string calldata _line2,\n        string calldata _line3\n    ) external {\n        haiku = SillyStringUtils.Haiku(_line1, _line2, _line3);\n    }\n\n    function getHaiku() external view returns (SillyStringUtils.Haiku memory) {\n        return haiku;\n    }\n\n    function shruggieHaiku()\n        external\n        view\n        returns (SillyStringUtils.Haiku memory _haiku)\n    {\n        _haiku = haiku;\n        _haiku.line3 = _haiku.line3.shruggie();\n    }\n}\n"
    },
    "contracts/Imports/SillyStringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary SillyStringUtils {\n    struct Haiku {\n        string line1;\n        string line2;\n        string line3;\n    }\n\n    function shruggie(\n        string memory _input\n    ) internal pure returns (string memory) {\n        return string.concat(_input, unicode\" ðŸ¤·\");\n    }\n}\n"
    },
    "contracts/Inheritance/InheritanceSubmission.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract InheritanceSubmission {\n    address public salesPerson;\n    address public engineeringManager;\n\n    constructor(address _salesPerson, address _engineeringManager) {\n        salesPerson = _salesPerson;\n        engineeringManager = _engineeringManager;\n    }\n}\n\nabstract contract Employee {\n    uint public idNumber;\n    uint public managerId;\n\n    constructor(uint _idNumber, uint _managerId) {\n        idNumber = _idNumber;\n        managerId = _managerId;\n    }\n\n    function getAnnualCost() external view virtual returns (uint) {}\n}\n\ncontract Salaried is Employee {\n    uint public annualSalary;\n\n    constructor(\n        uint _idNumber,\n        uint _managerId,\n        uint _annualSalary\n    ) Employee(_idNumber, _managerId) {\n        annualSalary = _annualSalary;\n    }\n\n    function getAnnualCost() external view override returns (uint) {\n        return annualSalary;\n    }\n}\n\ncontract Hourly is Employee {\n    uint public hourlyRate;\n\n    constructor(\n        uint _idNumber,\n        uint _managerId,\n        uint _hourlyRate\n    ) Employee(_idNumber, _managerId) {\n        hourlyRate = _hourlyRate;\n    }\n\n    function getAnnualCost() external view override returns (uint) {\n        return hourlyRate * 2080;\n    }\n}\n\ncontract Manager {\n    uint[] public employeeIds;\n\n    function addReport(uint256 _idNumber) external {\n        employeeIds.push(_idNumber);\n    }\n\n    function resetReports() external {\n        delete employeeIds;\n    }\n}\n\ncontract Salesperson is Hourly {\n    constructor(\n        uint256 _idNumber,\n        uint256 _managerId,\n        uint256 _hourlyRate\n    ) Hourly(_idNumber, _managerId, _hourlyRate) {}\n}\n\ncontract EngineeringManager is Salaried, Manager {\n    constructor(\n        uint256 _idNumber,\n        uint256 _managerId,\n        uint256 _annualSalary\n    ) Salaried(_idNumber, _managerId, _annualSalary) {}\n}\n"
    },
    "contracts/Mappings/FavoriteRecords.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract FavoriteRecords {\n    mapping(string => bool) public approvedRecords;\n    mapping(address => mapping(string => bool)) userFavorites;\n    string[] listOfApprovedRecords;\n\n    error NotApproved(string _album);\n\n    constructor(string[] memory _albums) {\n        uint _length = _albums.length;\n\n        for (uint i; i < _length; i++) {\n            approvedRecords[_albums[i]] = true;\n            listOfApprovedRecords.push(_albums[i]);\n        }\n    }\n\n    function getApprovedRecords() external view returns (string[] memory) {\n        return listOfApprovedRecords;\n    }\n\n    function addRecord(string calldata _album) external {\n        if (!approvedRecords[_album]) {\n            revert NotApproved(_album);\n        }\n\n        userFavorites[msg.sender][_album] = true;\n    }\n\n    function getUserFavorites(\n        address _user\n    ) external view returns (string[] memory _favorites) {\n        uint _lengthOfApprovedRecords = listOfApprovedRecords.length;\n        uint _lengthOfFavorites = 0;\n\n        for (uint i; i < _lengthOfApprovedRecords; i++) {\n            string storage _approvedRecord = listOfApprovedRecords[i];\n\n            if (userFavorites[_user][_approvedRecord] == true) {\n                _lengthOfFavorites++;\n            }\n        }\n\n        _favorites = new string[](_lengthOfFavorites);\n        uint _index = 0;\n\n        for (uint i; i < _lengthOfApprovedRecords; i++) {\n            string storage _approvedRecord = listOfApprovedRecords[i];\n\n            if (userFavorites[_user][_approvedRecord] == true) {\n                _favorites[_index] = _approvedRecord;\n                _index++;\n            }\n        }\n    }\n\n    function resetUserFavorites() external {\n        uint _lengthOfApprovedRecords = listOfApprovedRecords.length;\n\n        for (uint i; i < _lengthOfApprovedRecords; i++) {\n            delete userFavorites[msg.sender][listOfApprovedRecords[i]];\n        }\n    }\n}\n"
    },
    "contracts/Storage/EmployeeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract EmployeeStorage {\n    uint16 private shares;\n    uint32 private salary;\n    uint public idNumber;\n    string public name;\n\n    constructor(\n        uint16 _shares,\n        string memory _name,\n        uint32 _salary,\n        uint _idNumber\n    ) {\n        shares = _shares;\n        name = _name;\n        salary = _salary;\n        idNumber = _idNumber;\n    }\n\n    function viewSalary() external view returns (uint32) {\n        return salary;\n    }\n\n    function viewShares() external view returns (uint16) {\n        return shares;\n    }\n\n    error TooManyShares(uint16 _shares);\n\n    function grantShares(uint16 _newShares) public {\n        require(_newShares <= 5000, \"Too many shares\");\n\n        uint16 _shares = shares + _newShares;\n\n        if (_shares > 5000) {\n            revert TooManyShares(_shares);\n        }\n\n        shares = _shares;\n    }\n\n    /**\n     * Do not modify this function.  It is used to enable the unit test for this pin\n     * to check whether or not you have configured your storage variables to make\n     * use of packing.\n     *\n     * If you wish to cheat, simply modify this function to always return `0`\n     * I'm not your boss Â¯\\_(ãƒ„)_/Â¯\n     *\n     * Fair warning though, if you do cheat, it will be on the blockchain having been\n     * deployed by your wallet....FOREVER!\n     */\n    function checkForPacking(uint _slot) public view returns (uint r) {\n        assembly {\n            r := sload(_slot)\n        }\n    }\n\n    /**\n     * Warning: Anyone can use this function at any time!\n     */\n    function debugResetShares() public {\n        shares = 1000;\n    }\n}\n"
    },
    "contracts/Structs/GarageManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ncontract GarageManager {\n    struct Car {\n        string make;\n        string model;\n        string color;\n        uint numberOfDoors;\n    }\n\n    mapping(address => Car[]) public garage;\n\n    function addCar(\n        string calldata _make,\n        string calldata _model,\n        string calldata _color,\n        uint _numberOfDoors\n    ) external {\n        garage[msg.sender].push(Car(_make, _model, _color, _numberOfDoors));\n    }\n\n    function getUserCars(address _user) public view returns (Car[] memory) {\n        return garage[_user];\n    }\n\n    function getMyCars() external view returns (Car[] memory) {\n        return getUserCars(msg.sender);\n    }\n\n    error BadCarIndex(uint _index);\n\n    function updateCar(\n        uint _index,\n        string calldata _make,\n        string calldata _model,\n        string calldata _color,\n        uint _numberOfDoors\n    ) external {\n        if (_index >= garage[msg.sender].length) {\n            revert BadCarIndex(_index);\n        }\n\n        garage[msg.sender][_index] = Car(_make, _model, _color, _numberOfDoors);\n    }\n\n    function resetMyGarage() external {\n        delete garage[msg.sender];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}